#!/bin/bash

export LANG=C
CORP=$1
#
#N=`find $1 -type f | wc -l`
#find $1 -type f -exec ~/featurekit/dosteminline {} \; | sort -k3 | tee concordance.$1 | sed -e 's/.* //' | uniq -c > vocab.$1

: '
    zcat permite ver o conteúdo de um arquivo comprimido
        sem ter que descomprimi-lo.

    o conteúdo dentro de $CORP.tgz é passado para tar4
        (que aparenta ser um programa compilado).

    a saída de tar4 é ordenada de forma crescente (considerando
        a ordem na tabela ASCII) com base na terceira coluna (a saída de
        `.tar4 /dev/stdin` deve ser no formato de colunas).

    os erros que ocorrerem são enviados para dofast.stderr (<arquivo1> 2> <arquivo2>
        significa enviar o stderror de <arquivo1> para <arquivo2>).
'

zcat $CORP.tgz | ./tar4 /dev/stdin | sort -k3 > $CORP.concordance 2> dofast.stderr

#find $1 -name '*.vocab' -exec grep -H . {} \; 2> /dev/null  | sort -k3 > concordance.$1
#find $1 -name '*vocab' -exec cat {} \; 2> /dev/null | sed -e 's/.* //' | sort | uniq -c > vocab.$1

#join -o1.1,1.2 -v1 -12 vocab.$1 ~/featurekit/english.stop.stem | grep -v '^1 ' > df.$1
mv df $CORP.df
: '
    o join está sendo feito no terceiro campo do primeiro arquivo (-13) e no terceiro
        campo do segundo arquivo (-23). O hífen significa que o join irá ocorrer entre o
        conteúdo do arquivo anterior ($CORP.df) e o que for "digitado" depois ($CORP.concordance).
'

cat -n $CORP.df | join -13 -23 - $CORP.concordance | sort -k4,4 -k2,2n > $CORP.tfdf

N=`cat N`
echo N $N
../dotfidfinline $N < $CORP.tfdf > $CORP.svm.fil
